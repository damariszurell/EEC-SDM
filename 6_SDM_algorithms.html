<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>SDM algorithms</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/anchor-sections-1.0/anchor-sections.css" rel="stylesheet" />
<script src="site_libs/anchor-sections-1.0/anchor-sections.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Species distribution modelling</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="schedule.html">Course schedule</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    R practicals
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="0_Intro.html">0. Introduction to R</a>
    </li>
    <li>
      <a href="1_SpeciesData.html">1. Species data</a>
    </li>
    <li>
      <a href="2_EnvData.html">2. Environmental data</a>
    </li>
    <li>
      <a href="3_SDM_intro.html">3. SDMs: simple model fitting</a>
    </li>
    <li>
      <a href="4_SDM_eval.html">4. SDMs: assessment and prediction</a>
    </li>
    <li>
      <a href="5_pseudoabsence.html">5. Pseudo-absence and background data</a>
    </li>
    <li>
      <a href="6_SDM_algorithms.html">6. SDMs: algorithms</a>
    </li>
    <li>
      <a href="7_SDM_ensembles.html">7. SDMs: ensembles</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://damariszurell.github.io">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="https://twitter.com/ZurellLab">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">SDM algorithms</h1>

</div>


<div class="alert alert-info">
<p><strong>RStudio project</strong></p>
<p>Open the RStudio project that we created in the first session. I recommend to use this RStudio project for the entire course and within the RStudio project create separate R scripts for each session.</p>
<ul>
<li>Create a new empty R script by going to the tab “File”, select “New File” and then “R script”</li>
<li>In the new R script, type <code># Session 6: SDM algorithms</code> and save the file in your folder “scripts” within your project folder, e.g. as “6_SDM_algorithms.R”</li>
</ul>
</div>
<div id="introduction" class="section level1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>So far, we have learnt to fit GLMs to species presence-absence data. GLMs are only one, very simple parametric method for fitting SDMs. There are many more algorithms out there <span class="citation">(Elith et al. 2006; Thuiller et al. 2009; Guisan, Thuiller, and Zimmermann 2017)</span>. Here, we will get to know a few of them. Remember the five general model building steps: (i) conceptualisation, (ii) data preparation, (iii) model fitting, (iv) assessment and (v) predictions <span class="citation">(Zurell et al. 2020)</span>. These are the same for all SDMs independent of the particular algorithm used. In this tutorial, we will concentrate on model fitting again but will also run model assessments and make predictions in order to compare the different algorithms.</p>
<div id="recap-of-last-session-data-and-model-building-steps" class="section level2">
<h2><span class="header-section-number">1.1</span> Recap of last session: data and model building steps</h2>
<p>I will illustrate the different algorithms using the Ring Ouzel example of sessions 3-4, based on data from the British breeding and wintering birds citizen science atlas <span class="citation">(Gillings et al. 2019)</span>. The species presense/absence data and the bioclimatic variables at these locations are available from file. Also, remember that we have already tested the data for multicollinearity and identified bio11 and bio8 as weakly correlated variables with high univariate variable importance.</p>
<pre class="r"><code>library(raster)
bg &lt;- raster(&#39;data/Prac3_UK_mask.grd&#39;)</code></pre>
<pre><code>## Warning in showSRID(uprojargs, format = &quot;PROJ&quot;, multiline = &quot;NO&quot;, prefer_proj =
## prefer_proj): Discarded datum OSGB 1936 in CRS definition</code></pre>
<pre class="r"><code>sp_dat &lt;- read.table(&#39;data/Prac3_RingOuzel.txt&#39;,header=T)

my_preds &lt;- c(&#39;bio11&#39;,&#39;bio8&#39;)</code></pre>
<p>In session 4 on model assessment, we learned that the models should be validated on indepedent validation data and we have learned how to run a 5-fold cross-validation. The <code>crossvalSDM()</code> function could also be used with the algorithms introduced in this practical. However, to simplfy matters let’s rather split the data into training data and testing data once. For a proper validation this split-sample should be repeated many times. Nevertheless, this unique split-sample will still give us an idea of model performance and will allow us to compare the different algorithms.</p>
<pre class="r"><code># First, we randomly select 70% of the rows that will be used as training data
train_i &lt;- sample(seq_len(nrow(sp_dat)), size=round(0.7*nrow(sp_dat)))

# Then, we can subset the training and testing data
sp_train &lt;- sp_dat[train_i,]
sp_test &lt;- sp_dat[-train_i,]

# We store the split information for later:
write(train_i, file=&#39;data/indices_traindata.txt&#39;)</code></pre>
<p>For making predictions in space, we also load the current climate layers that we downloaded and processed previously. Please remember that the worldclim layers come in geographic projection in lon/lat format while the bird data are sampled on the British National Grid. To harmonise these data, we reproject the climate data onto the National Grid.</p>
<pre class="r"><code>library(raster)

bio_curr &lt;- stack(&#39;data/Prac4_UK_bio_curr.grd&#39;)</code></pre>
</div>
</div>
<div id="model-algorithms" class="section level1">
<h1><span class="header-section-number">2</span> Model algorithms</h1>
<p>Typically, you should decide on appropriate modelling algorithms during the conceptualisation phase. Let’s assume our study objectives were to compare species-environment relationships and predicted species distributions across several SDM algorithms, for example to quantify the uncertainty due to the model class <span class="citation">(Araujo and New 2007; Thuiller et al. 2009; Buisson et al. 2010)</span>. We will test several different SDM algorithms that can be broadly classified into profile (envelope and distance-based) methods, regression-based methods and non-parametric machine-learning methods <span class="citation">(Guisan, Thuiller, and Zimmermann 2017)</span>(<a href="http://rspatial.org/sdm/rst/6_sdm_methods.html" class="uri">http://rspatial.org/sdm/rst/6_sdm_methods.html</a>). The list of models we treat here is not exhaustive but should give you a rough overview of what concepts and methods are out there. Most of the methods used here are available in the package <code>dismo</code>.</p>
<div id="profile-envelope-and-distance-based-methods" class="section level2">
<h2><span class="header-section-number">2.1</span> Profile (envelope and distance-based) methods</h2>
<p>Profile methods constitute the oldest family of SDM algorithms and are the only “true” presence-only methods that do not need any absence or background data. We can distinguish the classical envelope approach and distance-based methods.</p>
<div id="bioclim" class="section level3">
<h3><span class="header-section-number">2.1.1</span> BIOCLIM</h3>
<p>BIOCLIM is a pioneering envelope approach <span class="citation">(Booth et al. 2014)</span>. It defines the niche as an <em>n</em>-dimensional, rectangular bounding box, which is similar to Hutchinson’s view of the <em>n</em>-dimensional hyperspace <span class="citation">(Hutchinson 1957)</span>. To reduce sensitivity to outliers, the bounding box can be limited by only considering a certain percentile range (e.g. 5-95%) of the species records along each environmental gradient. In <code>dismo</code>, the BIOCLIM algorithm is implemented such that it will produce continuous probabilities between 0 and 1, indicating how similar/close the environmental conditions are to the median conditions.</p>
<pre class="r"><code>library(dismo)

# Fit BIOCLIM model
m_bc &lt;- bioclim(bio_curr[[my_preds]], 
                sp_train[sp_train$Turdus_torquatus==1,c(&#39;EASTING&#39;,&#39;NORTHING&#39;)])
plot(m_bc)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>The resulting plot shows the bounding box (5-95% percentile range). The red cross within the box is the median. We can also visualise this a response surface to get a better idea what BIOCLIM is predicting.</p>
<pre class="r"><code># For the response surface, we first prepare the 3D-grid with environmental gradient and predictions
xyz &lt;- expand.grid(
    seq(min(sp_train[,my_preds[1]]),max(sp_train[,my_preds[1]]),length=50),
    seq(min(sp_train[,my_preds[2]]),max(sp_train[,my_preds[2]]),length=50))
names(xyz) &lt;- my_preds
# Make predictions to gradients:
xyz$z &lt;- predict(m_bc, xyz)

# Define colour palette:
library(RColorBrewer)
cls &lt;- colorRampPalette(rev(brewer.pal(11, &#39;RdYlBu&#39;)))(100)

# Plot response surface:
library(lattice)
wireframe(z ~ bio11 + bio8, data = xyz, zlab = list(&quot;Occurrence prob.&quot;, rot=90), 
          drape = TRUE, col.regions = cls, scales = list(arrows = FALSE), 
          zlim = c(0, 1), main=&#39;BIOCLIM&#39;, xlab=&#39;bio11&#39;, ylab=&#39;bio8&#39;, 
          screen=list(z = -120, x = -70, y = 3))</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>We nicely see the median as the peak of the surface, representing the median environmental conditions in presence locations. Let’s look at the corresponding partial response plots.</p>
<pre class="r"><code>library(mecofun)

# Plot partial response curves:
par(mfrow=c(1,2)) 
partial_response(m_bc, predictors = sp_train[,my_preds], main=&#39;BIOCLIM&#39;)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>Last, we validate model performance on the hold-out test data.</p>
<pre class="r"><code># We use the default MaxSens+Spec threshold:
(perf_bc &lt;- evalSDM(sp_test$Turdus_torquatus, predict(m_bc, sp_test[,my_preds])))</code></pre>
<pre><code>##        AUC       TSS     Kappa Sens      Spec       PCC         D2 thresh
## 1 0.794807 0.6102941 0.4317295 0.75 0.8602941 0.8486842 -0.4583228   0.26</code></pre>
<p>Finally, let’s map the predicted occurrence probabilities across Britain and the predicted presence/absence.</p>
<pre class="r"><code># Map predictions:
r_bc_pred &lt;- r_bc_bin &lt;- predict(m_bc,bio_curr)

# Threshold predictions using the maxTSS threshold (max sens+spec)
values(r_bc_bin) &lt;- ifelse(values(r_bc_pred)&gt;=perf_bc$thresh, 1, 0)

# plot the maps
plot(stack(r_bc_pred, r_bc_bin),main=c(&#39;BIOCLIM prob.&#39;,&#39;BIOCLIM bin.&#39;), axes=F) </code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
</div>
<div id="domain" class="section level3">
<h3><span class="header-section-number">2.1.2</span> Domain</h3>
<p>Instead of drawing rectangular envelopes, distance-based methods such as the <em>Domain</em> evaluate the environmental similarity between a “new” site and sites with known presences. <em>Domain</em> uses the Gower distance for assessing similarity.</p>
<pre class="r"><code># Fit Domain model
m_dom &lt;- domain(bio_curr[[my_preds]], 
                sp_train[sp_train$Turdus_torquatus==1,c(&#39;EASTING&#39;,&#39;NORTHING&#39;)])

# Now, we plot the response surface:
xyz$z &lt;- predict(m_dom, xyz)

wireframe(z ~ bio11 + bio8, data = xyz, zlab = list(&quot;Occurrence prob.&quot;, rot=90), 
          drape = TRUE, col.regions = cls, scales = list(arrows = FALSE), 
          zlim = c(0, 1), main=&#39;Domain&#39;, xlab=&#39;bio11&#39;, ylab=&#39;bio8&#39;, 
          screen=list(z = -120, x = -70, y = 3))</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<pre class="r"><code># Plot partial response curves:
par(mfrow=c(1,2)) 
partial_response(m_dom, predictors = sp_train[,my_preds], main=&#39;DOMAIN&#39;)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-10-2.png" width="672" /></p>
<pre class="r"><code># Performance measures
(perf_dom &lt;- evalSDM(sp_test$Turdus_torquatus, predict(m_dom, sp_test[,my_preds])))</code></pre>
<pre><code>##         AUC       TSS     Kappa Sens      Spec       PCC        D2 thresh
## 1 0.7821691 0.5441176 0.3274336 0.75 0.7941176 0.7894737 -1.085684   0.68</code></pre>
<pre class="r"><code># Map predictions:
r_dom_pred &lt;- r_dom_bin &lt;- predict(m_dom,bio_curr[[my_preds]])
values(r_dom_bin) &lt;- ifelse(values(r_dom_pred)&gt;=perf_dom$thresh, 1, 0)
plot(stack(r_dom_pred, r_dom_bin),main=c(&#39;Domain prob.&#39;,&#39;Domain bin.&#39;), axes=F) </code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-10-3.png" width="672" /></p>
</div>
</div>
<div id="regression-based-methods" class="section level2">
<h2><span class="header-section-number">2.2</span> Regression-based methods</h2>
<div id="generalised-linear-models-glms" class="section level3">
<h3><span class="header-section-number">2.2.1</span> Generalised linear models (GLMs)</h3>
<p>We already know GLMs from the previous tutorials. We can fit linear, quadratic or higher polynomial terms (check <code>poly()</code>) and interactions between predictors.</p>
<pre class="r"><code># Fit GLM
m_glm &lt;- step(glm( Turdus_torquatus ~ bio11 + I(bio11^2) + bio8 + I(bio8^2),
    family=&#39;binomial&#39;, data=sp_train))</code></pre>
<pre><code>## Start:  AIC=128.94
## Turdus_torquatus ~ bio11 + I(bio11^2) + bio8 + I(bio8^2)
## 
##              Df Deviance    AIC
## - I(bio8^2)   1   118.95 126.95
## - bio8        1   119.07 127.07
## - I(bio11^2)  1   119.20 127.20
## - bio11       1   119.25 127.25
## &lt;none&gt;            118.94 128.94
## 
## Step:  AIC=126.95
## Turdus_torquatus ~ bio11 + I(bio11^2) + bio8
## 
##              Df Deviance    AIC
## - bio11       1   119.48 125.48
## - I(bio11^2)  1   119.49 125.49
## &lt;none&gt;            118.95 126.95
## - bio8        1   123.59 129.59
## 
## Step:  AIC=125.48
## Turdus_torquatus ~ I(bio11^2) + bio8
## 
##              Df Deviance    AIC
## &lt;none&gt;            119.48 125.48
## - I(bio11^2)  1   124.17 128.17
## - bio8        1   127.82 131.82</code></pre>
<pre class="r"><code># Now, we plot the response surface:
xyz$z &lt;- predict(m_glm, xyz, type=&#39;response&#39;)

wireframe(z ~ bio11 + bio8, data = xyz, zlab = list(&quot;Occurrence prob.&quot;, rot=90), 
          drape = TRUE, col.regions = cls, scales = list(arrows = FALSE), 
          zlim = c(0, 1), main=&#39;GLM&#39;, xlab=&#39;bio11&#39;, ylab=&#39;bio8&#39;, 
          screen=list(z = -120, x = -70, y = 3))</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r"><code># Plot partial response curves:
par(mfrow=c(1,2)) 
partial_response(m_glm, predictors = sp_train[,my_preds], main=&#39;GLM&#39;)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-11-2.png" width="672" /></p>
<pre class="r"><code># Performance measures
(perf_glm &lt;- evalSDM(sp_test$Turdus_torquatus, predict(m_glm, sp_test[,my_preds], type=&#39;response&#39;) ))</code></pre>
<pre><code>##        AUC       TSS     Kappa  Sens      Spec       PCC        D2 thresh
## 1 0.933364 0.7352941 0.5006258 0.875 0.8602941 0.8618421 0.4607125   0.12</code></pre>
<pre class="r"><code># Map predictions:
bio_curr_df &lt;- data.frame(rasterToPoints(bio_curr[[my_preds]]))
r_glm_bin &lt;- r_glm_pred &lt;- rasterFromXYZ(cbind(bio_curr_df[,1:2],
                                  predict(m_glm, bio_curr_df, type=&#39;response&#39;)))
values(r_glm_bin) &lt;- ifelse(values(r_glm_pred)&gt;=perf_glm$thresh, 1, 0)
plot(stack(r_glm_pred, r_glm_bin),main=c(&#39;GLM prob.&#39;,&#39;GLM bin.&#39;), axes=F)   </code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-11-3.png" width="672" /></p>
</div>
<div id="generalised-additive-models-gams" class="section level3">
<h3><span class="header-section-number">2.2.2</span> Generalised additive models (GAMs)</h3>
<p>GAMs are a semi-parametric regression method that use data-defined, non-parametric smoothing functions to fit non-linear species-environment relationships. GAMs do not fit the response function to all data points at once, but use a moving-window approach to fit a local smoother to a proportion of the data. Small window sizes will yield highly flexible response shapes while large window sizes will produce less flexible response shapes that are closer to a parametric GLM. Two packages for fitting GAMs are available in R: <em>mgcv</em> and <em>gam</em>. Both allow fitting spline smoother <code>s()</code> while the package <em>gam</em> also allows fitting a loess function <code>lo()</code>. The <em>mgcv</em> package allows more control over model fitting and optimization, but here we use the package <em>gam</em> to illustrate differences between loess and splines.</p>
<pre class="r"><code>library(gam)

# Fit GAM with spline smoother
m_gamS &lt;- gam( Turdus_torquatus ~ s(bio11,df=4) + s(bio8, df=4),
    family=&#39;binomial&#39;, data=sp_train)

# Fit GAM with loess
m_gamL &lt;- gam( Turdus_torquatus ~ lo(bio11) + lo(bio8),
    family=&#39;binomial&#39;, data=sp_train)


# Now, we plot the response surface:
xyz$z &lt;- predict(m_gamS, xyz[,1:2], type=&#39;response&#39;)
wireframe(z ~ bio11 + bio8, data = xyz, zlab = list(&quot;Occurrence prob.&quot;, rot=90), 
          drape = TRUE, col.regions = cls, scales = list(arrows = FALSE), 
          zlim = c(0, 1), main=&#39;GAM (splines)&#39;, xlab=&#39;bio11&#39;, ylab=&#39;bio8&#39;, 
          screen=list(z = -120, x = -70, y = 3))</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<pre class="r"><code>xyz$z &lt;- predict(m_gamL, xyz[,1:2], type=&#39;response&#39;)
wireframe(z ~ bio11 + bio8, data = xyz, zlab = list(&quot;Occurrence prob.&quot;, rot=90), 
          drape = TRUE, col.regions = cls, scales = list(arrows = FALSE), 
          zlim = c(0, 1), main=&#39;GAM (loess)&#39;, xlab=&#39;bio11&#39;, ylab=&#39;bio8&#39;, 
          screen=list(z = -120, x = -70, y = 3))</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-12-2.png" width="672" /></p>
<pre class="r"><code># Plot partial response curves:
par(mfrow=c(2,2)) 
partial_response(m_gamS, predictors = sp_train[,my_preds], main=&#39;GAM (splines)&#39;)
partial_response(m_gamL, predictors = sp_train[,my_preds], main=&#39;GAM (loess)&#39;)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-12-3.png" width="672" /></p>
<pre class="r"><code># Performance measures
(perf_gamS &lt;- evalSDM(sp_test$Turdus_torquatus, predict(m_gamS, sp_test[,my_preds], type=&#39;response&#39;) ))</code></pre>
<pre><code>##      AUC       TSS     Kappa   Sens      Spec       PCC        D2 thresh
## 1 0.9375 0.7757353 0.4912689 0.9375 0.8382353 0.8486842 0.4586095    0.1</code></pre>
<pre class="r"><code>(perf_gamL &lt;- evalSDM(sp_test$Turdus_torquatus, predict(m_gamL, sp_test[,my_preds], type=&#39;response&#39;) ))</code></pre>
<pre><code>##         AUC       TSS     Kappa   Sens      Spec       PCC        D2 thresh
## 1 0.9214154 0.7757353 0.4912689 0.9375 0.8382353 0.8486842 0.4508137   0.09</code></pre>
<pre class="r"><code># Map predictions:
r_gamS_bin &lt;- r_gamS_pred &lt;- rasterFromXYZ(cbind(bio_curr_df[,1:2],
                                   predict(m_gamS, bio_curr_df, type=&#39;response&#39;)))
values(r_gamS_bin) &lt;- ifelse(values(r_gamS_pred)&gt;=perf_gamS$thresh, 1, 0)
plot(stack(r_gamS_pred, r_gamS_bin),
     main=c(&#39;GAM (splines) prob.&#39;,&#39;GAM (splines) bin.&#39;), axes=F)    </code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-12-4.png" width="672" /></p>
</div>
</div>
<div id="machine-learning-methods" class="section level2">
<h2><span class="header-section-number">2.3</span> Machine-learning methods</h2>
<p>There are a number of different non-parametric machine-learning methods that are commonly used in SDMs, and new methods are constantly appearing. A few methods like Classification and Regression Trees (CART) and Artificial Neural Networks (ANN) have been around for some time, while other methods such as Boosted Regression Trees (BRTs), Random Forests (RFs) and Maximum Entropy (MaxEnt) have only become popular over the last decade.</p>
<div id="classification-and-regression-trees-cart" class="section level3">
<h3><span class="header-section-number">2.3.1</span> Classification and regression trees (CART)</h3>
<p>CARTs are a recursive partitioning method that aim to divide the data into homogeneous subgroups <span class="citation">(Franklin 2010; Guisan, Thuiller, and Zimmermann 2017)</span>. They grow a decision tree by repeatedly splitting the data such that the splits help separating presences and absences. Thus, CARTs search along each environmental gradient for those splitting rules (nodes) that best separate the observations. Of course, we could perfectly fit all data by that procedure, which is rarely desirable as it will decrease the bias for the training data but increase the variance for a different sample (the <em>bias-variance tradeoff</em>). Thus, the procedure is basically to grow the tree, stop the tree and prune the tree to find the optimal tree size.</p>
<p>Again, different packages are available for fitting CARTs, e.g. <em>rpart</em> and <em>tree</em>. The package <em>rpart</em> offers better control of model fitting and tree size optimization. It uses internal cross-validation (default <code>xval=10</code>) for evaluating bias-variance tradeoff and optimizing tree size. Another important control parameter is the minimum number of observations (default <code>minsplit=20</code>) that must be available to define a split.</p>
<pre class="r"><code>library(rpart)

# Fit CART
m_cart &lt;- rpart(Turdus_torquatus ~ bio11 + bio8,
    data=sp_train, control=rpart.control(minsplit=20,xval=10))
    
# Have a look at the data splits:
print(m_cart)</code></pre>
<pre><code>## n= 355 
## 
## node), split, n, deviance, yval
##       * denotes terminal node
## 
##  1) root 355 24.946480 0.07605634  
##    2) bio8&gt;=34.17421 308  6.840909 0.02272727  
##      4) bio11&gt;=21.48355 296  3.945946 0.01351351 *
##      5) bio11&lt; 21.48355 12  2.250000 0.25000000 *
##    3) bio8&lt; 34.17421 47 11.489360 0.42553190  
##      6) bio8&gt;=15.52276 38  8.552632 0.34210530  
##       12) bio8&lt; 30.85739 31  6.387097 0.29032260  
##         24) bio8&gt;=28.96574 8  0.000000 0.00000000 *
##         25) bio8&lt; 28.96574 23  5.478261 0.39130430 *
##       13) bio8&gt;=30.85739 7  1.714286 0.57142860 *
##      7) bio8&lt; 15.52276 9  1.555556 0.77777780 *</code></pre>
<pre class="r"><code>plot(m_cart, margin=0.1)
text(m_cart, cex = 0.8)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<pre class="r"><code># Now, we plot the response surface:
xyz$z &lt;- predict(m_cart, xyz)
wireframe(z ~ bio11 + bio8, data = xyz, zlab = list(&quot;Occurrence prob.&quot;, rot=90), 
          drape = TRUE, col.regions = cls, scales = list(arrows = FALSE), 
          zlim = c(0, 1), main=&#39;CART&#39;, xlab=&#39;bio11&#39;, ylab=&#39;bio8&#39;, 
          screen=list(z = -120, x = -70, y = 3))</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-13-2.png" width="672" /></p>
<pre class="r"><code># Plot partial response curves:
par(mfrow=c(1,2)) 
partial_response(m_cart, predictors = sp_train[,my_preds], main=&#39;CART&#39;)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-13-3.png" width="672" /></p>
<pre class="r"><code># Performance measures of GAM with spline-smoother 
(perf_cart &lt;- evalSDM(sp_test$Turdus_torquatus, predict(m_cart, sp_test[,my_preds]) ))</code></pre>
<pre><code>##         AUC       TSS     Kappa Sens      Spec       PCC        D2 thresh
## 1 0.8244485 0.6323529 0.4751381 0.75 0.8823529 0.8684211 0.2546056   0.32</code></pre>
<pre class="r"><code># Map predictions:
r_cart_bin &lt;- r_cart_pred &lt;- rasterFromXYZ(cbind(bio_curr_df[,1:2],
                                   predict(m_cart, bio_curr_df)))
values(r_cart_bin) &lt;- ifelse(values(r_cart_pred)&gt;=perf_cart$thresh, 1, 0)
plot(stack(r_cart_pred, r_cart_bin),main=c(&#39;CART prob.&#39;,&#39;CART bin.&#39;), axes=F)   </code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-13-4.png" width="672" /></p>
</div>
<div id="random-forests-rfs" class="section level3">
<h3><span class="header-section-number">2.3.2</span> Random Forests (RFs)</h3>
<p>Regression models or classification models can be affected by local optima and noise in the data. They usually have low bias (fit the training data very well) but high variance (noisy/poorer performance when predicting to non-training data). Model averaging has been proposed as possible solution <span class="citation">(Hastie, Tibshirani, and Friedman 2009)</span>. In recent years, so-called bagging and boosting methods have been developed for combining or averaging different models. Random Forests use a bagging procedure for averaging the outputs of a multitude of different CARTs. Bagging stands for “bootstrap aggregation”. Basically, we fit many CARTs to bootstrapped samples of the training data and then either average the results in case of regression trees or make a simple vote in case of classification trees (committee averaging)<span class="citation">(Hastie, Tibshirani, and Friedman 2009; Guisan, Thuiller, and Zimmermann 2017)</span>. An important feature of Random Forests are the out-of-bag samples, which means that the predictions/fit for a specific data point is only derived from averaging trees that did not include this data point during tree growing. Thus, the output of Random Forests is essentially cross-validated. Random Forests estimate variable importance by a permutation procedure, which measures for each variable the drop in mean accuracy when this variables is permutated.</p>
<pre class="r"><code>library(randomForest)

# Fit RF
m_rf &lt;- randomForest( x=sp_train[,my_preds], y=sp_train$Turdus_torquatus, 
    ntree=1000, importance =T)
    
# Variable importance:
importance(m_rf,type=1)</code></pre>
<pre><code>##        %IncMSE
## bio11 17.92581
## bio8  21.05596</code></pre>
<pre class="r"><code>varImpPlot(m_rf)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<pre class="r"><code># Look at single trees:
head(getTree(m_rf,1,T))</code></pre>
<pre><code>##   left daughter right daughter split var split point status prediction
## 1             2              3      bio8    35.98936     -3 0.09295775
## 2             4              5     bio11     1.40692     -3 0.41666667
## 3             6              7     bio11    21.71712     -3 0.02711864
## 4             0              0      &lt;NA&gt;     0.00000     -1 1.00000000
## 5             8              9     bio11    22.75861     -3 0.33962264
## 6            10             11     bio11    20.92356     -3 0.40000000</code></pre>
<pre class="r"><code># Now, we plot the response surface:
xyz$z &lt;- predict(m_rf, xyz, type=&#39;response&#39;)
wireframe(z ~ bio11 + bio8, data = xyz, zlab = list(&quot;Occurrence prob.&quot;, rot=90), 
          drape = TRUE, col.regions = cls, scales = list(arrows = FALSE), 
          zlim = c(0, 1), main=&#39;Random Forest&#39;, xlab=&#39;bio11&#39;, ylab=&#39;bio8&#39;, 
          screen=list(z = -120, x = -70, y = 3))</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-14-2.png" width="672" /></p>
<pre class="r"><code># Plot partial response curves:
par(mfrow=c(1,2)) 
partial_response(m_rf, predictors = sp_train[,my_preds], main=&#39;Random Forest&#39;)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-14-3.png" width="672" /></p>
<pre class="r"><code># Performance measures of GAM with spline-smoother 
(perf_rf &lt;- evalSDM(sp_test$Turdus_torquatus, predict(m_rf, sp_test[,my_preds],  type=&#39;response&#39;) ))</code></pre>
<pre><code>##         AUC       TSS     Kappa  Sens      Spec       PCC        D2 thresh
## 1 0.9067096 0.7205882 0.4728589 0.875 0.8455882 0.8486842 0.2236552   0.12</code></pre>
<pre class="r"><code># Map predictions:
r_rf_bin &lt;- r_rf_pred &lt;- rasterFromXYZ(cbind(bio_curr_df[,1:2],
                                 predict(m_rf, bio_curr_df,type=&#39;response&#39;)))
values(r_rf_bin) &lt;- ifelse(values(r_rf_pred)&gt;=perf_rf$thresh, 1, 0)
plot(stack(r_rf_pred, r_rf_bin),main=c(&#39;RF prob.&#39;,&#39;RF bin.&#39;), axes=F)   </code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-14-4.png" width="672" /></p>
</div>
<div id="boosted-regression-trees-brts" class="section level3">
<h3><span class="header-section-number">2.3.3</span> Boosted regression trees (BRTs)</h3>
<p>Boosting is another averaging/ensemble approach for improving the predictive performance of models <span class="citation">(Hastie, Tibshirani, and Friedman 2009; Guisan, Thuiller, and Zimmermann 2017)</span>. Boosting of CARTS is known under different names including Gradient Boosting Machine (GBM), Generalised Boosted Regression Model (GBM) and Boosted Regression Trees (BRTs) among others. In R it is available in the package <em>gbm</em> with some additional functions from <span class="citation">Elith, Leathwick, and Hastie (2008)</span> provided in the <em>dismo</em> package. <span class="citation">Elith, Leathwick, and Hastie (2008)</span> also provide a working guide for using BRTs in species distribution modelling. Unlike Random Forests, BRTs iteratively fit relatively simple trees by putting emphasis on observations fitted poorly by the previous trees (by fitting the new tree to the residuals of the previous tree). The final BRT can be thought of as linear combination of all trees, similar to a regression model where each term is a single tree <span class="citation">(Elith, Leathwick, and Hastie 2008)</span>. Thereby each tree is shrunk by the learning rate (the shrinkage parameter, typically &lt;1), which determines how much weight is given to single trees. Generally, slower learning (meaning smaller learning rates) are preferable. Similarly to Random Forests, only a subset of the data (the <em>bag fraction</em>) is used for fitting consecutive trees (but in contrast to Random Forests, the subsets are sampled without replacement and thus constitute real data splits). This <em>bag fraction</em> should typically range 0.5-0.75 <span class="citation">(Elith, Leathwick, and Hastie 2008)</span>. The tree complexity controls the interaction depth; <code>1</code> means only tree stumps (with two terminal nodes) are fitted, <code>2</code> means a model with up to two-way interactions etc. In the regular <code>gbm()</code>function, you have to define the maximum number of trees fitted. <span class="citation">Elith, Leathwick, and Hastie (2008)</span> recommend fitting at least 1000 trees. However, you want to be careful not to overfit the model by fitting too many trees. The <em>dismo</em> package provides the function <code>gbm.step</code> that selects the optimum number of trees based on the reduction in deviance achieved by adding a tree while predicting to the hold-out data (1-<code>bag fraction</code>). If the optimal number of trees estimated by the model is below 1000, you should decrease your learning rate; if it is above 10000, you should increase your learning rate. A tutorial on BRTs is contained in the dismo package: <code>vignette('brt')</code></p>
<pre class="r"><code>library(gbm)

# Fit BRT
m_brt &lt;- gbm.step(data = sp_train, 
    gbm.x = my_preds,
    gbm.y = &#39;Turdus_torquatus&#39;, 
    family = &#39;bernoulli&#39;,
    tree.complexity = 2,
    bag.fraction = 0.75,
    learning.rate = 0.001,
    verbose=F)</code></pre>
<pre><code>## 
##  
##  GBM STEP - version 2.9 
##  
## Performing cross-validation optimisation of a boosted regression tree model 
## for NA and using a family of bernoulli 
## Using 355 observations and 2 predictors 
## creating 10 initial models of 50 trees 
## 
##  folds are stratified by prevalence 
## total mean deviance =  0.5381 
## tolerance is fixed at  5e-04 
## now adding trees...</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<pre class="r"><code># Variable importance:
m_brt$contributions</code></pre>
<pre><code>##         var  rel.inf
## bio8   bio8 57.57056
## bio11 bio11 42.42944</code></pre>
<pre class="r"><code># Interactions (not very meaningful here with only 2 predictors):
gbm.interactions(m_brt)$interactions</code></pre>
<pre><code>##       bio11  bio8
## bio11     0 50.44
## bio8      0  0.00</code></pre>
<pre class="r"><code>gbm.interactions(m_brt)$rank.list</code></pre>
<pre><code>##   var1.index var1.names var2.index var2.names int.size
## 1          2       bio8          1      bio11    50.44
## 2          3       &lt;NA&gt;          0                0.00</code></pre>
<pre class="r"><code># dismo provides some build-in functions for plotting response:
gbm.plot(m_brt, n.plots=2, write.title = FALSE)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-15-2.png" width="672" /></p>
<pre class="r"><code>gbm.plot.fits(m_brt)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-15-3.png" width="672" /></p>
<pre class="r"><code># Now, we plot the response surface:
xyz$z &lt;- predict.gbm(m_brt, xyz, n.trees=m_brt$gbm.call$best.trees, type=&quot;response&quot;)
wireframe(z ~ bio11 + bio8, data = xyz, zlab = list(&quot;Occurrence prob.&quot;, rot=90), 
          drape = TRUE, col.regions = cls, scales = list(arrows = FALSE), 
          zlim = c(0, 1), main=&#39;Boosted regression trees&#39;, xlab=&#39;bio11&#39;, 
          ylab=&#39;bio8&#39;, screen=list(z = -120, x = -70, y = 3))</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-15-4.png" width="672" /></p>
<pre class="r"><code># Plot partial response curves:
par(mfrow=c(1,2)) 
partial_response(m_brt, predictors = sp_train[,my_preds], main=&#39;BRT&#39;)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-15-5.png" width="672" /></p>
<pre class="r"><code># Performance measures of GAM with spline-smoother 
(perf_brt &lt;- evalSDM(sp_test$Turdus_torquatus, predict.gbm(m_brt, sp_test[,my_preds], n.trees=m_brt$gbm.call$best.trees, type=&#39;response&#39;) ))</code></pre>
<pre><code>##         AUC       TSS     Kappa Sens      Spec       PCC        D2 thresh
## 1 0.9356618 0.7426471 0.3779233    1 0.7426471 0.7697368 0.3950431   0.02</code></pre>
<pre class="r"><code># Map predictions:
r_brt_bin &lt;- r_brt_pred &lt;- rasterFromXYZ(cbind(bio_curr_df[,1:2],
                                  predict.gbm(m_brt, bio_curr_df,
                                              n.trees=m_brt$gbm.call$best.trees, 
                                              type=&quot;response&quot;)))
values(r_brt_bin) &lt;- ifelse(values(r_brt_pred)&gt;=perf_brt$thresh, 1, 0)
plot(stack(r_brt_pred, r_brt_bin),main=c(&#39;BRT prob.&#39;,&#39;BRT bin.&#39;), axes=F)   </code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-15-6.png" width="672" /></p>
</div>
<div id="maxent" class="section level3">
<h3><span class="header-section-number">2.3.4</span> Maxent</h3>
<p>In recent years, maximum entropy modelling of species distributions has become very popular and proved as one of the best-performing methods in model comparisons <span class="citation">Elith et al. (2006)</span>. The implementation <em>Maxent</em> <span class="citation">(Phillips, Anderson, and Schapire 2006; Elith et al. 2011; Merow, Smith, and Silander Jr 2013)</span> now constitutes the most widely used SDM algorithm. It was originally offered with a stand-alone Java package with user interface (possibly one reasons for its popularity). Since a couple of years, some packages like <em>dismo</em> have build-in functions to communicate with this Maxent programme. Very recently, Steven Phillips (“Mr. Maxent”) introduced a true R version of Maxent, the <em>maxnet</em> package.</p>
<p>Maxent is a presence-only method, but unlike profile methods it uses background data (where presence is unknown) against which it contrasts the observed presences. <span class="citation">Elith et al. (2011)</span> provide a simplified explanation of Maxent (while the original paper by <span class="citation">Phillips, Anderson, and Schapire (2006)</span> focused on explanations from machine-learning perspective) stating that Maxent aims to minimise the relative entropy between the probability density of presences and the probability density of the environment estimated in environmental (not geographic!) space. The density of available background data in environmental/covariate space can be regarded as the null model that assumes that the species will occupy environmental conditions proportional to their relative availability in the landscape <span class="citation">(Guisan, Thuiller, and Zimmermann 2017)</span>. Maxent allows fitting very complex, highly non-linear response shapes <span class="citation">(Merow, Smith, and Silander Jr 2013)</span>, defined by so-called feature classes. Maxent currently recognises six features classes, which are described in more detail by <span class="citation">Elith et al. (2011)</span> and <span class="citation">Merow, Smith, and Silander Jr (2013)</span>: linear, product, quadratic, hinge, threshold and categorical. We already know linear and quadratic features from GLMs. <em>Products</em> allow simple interactions between all possible pair-wise combinations of predictor variables. <em>Thresholds</em> allow a step in the fitted function (as we have seen in CARTs) and make a continuous predictor binary assigning 0 below the threshold and 1 above the threshold. <em>Hinge</em> features are similar to <em>thresholds</em> only that they do not fit abrupt steps but a change in the gradient of the response (a bit like piecewise linear splines). <em>Categorical</em> features split a predictor with <span class="math inline">\(n\)</span> categories (such as land cover) into <span class="math inline">\(n\)</span> binary features assigning 1 when the feature is expressed and 0 otherwise. If the data contain more than 80 presences, then Maxent will by default use all feature classes in model fitting (otherwise it will automatically determine the number of features based on the number of presences). This can easily lead to more features that are explored in the model than actual presences <span class="citation">(Merow, Smith, and Silander Jr 2013)</span>. Of course, users can also specify features themselves. Generally, the selection of features should be guided by ecological plausibility and be considered during model conceptualisation. During model fitting, Maxent will select features based on regularization (trading-off likelihood and model complexity) to avoid overfitting.</p>
<p>As the density of presence points in environmental space is contrasted against all available environments, choosing the background data can be quite crucial in Maxent and should be guided by the spatial scale of the ecological question <span class="citation">(Merow, Smith, and Silander Jr 2013)</span>. For example, the geographic extent of background data should only encompass areas that are accessible by dispersal and which the species is equally likely to reach. If there is reason to assume that the presence data are spatially biased, then this should also be considered when deriving background data, for example by inducing the same spatial bias in the background <span class="citation">(Kramer-Schadt et al. 2013)</span>. Here, we avoid the background data issue as we have true absence data available.</p>
<pre class="r"><code>library(maxnet)

# Fit Maxent
m_maxent &lt;- maxnet(p=sp_train$Turdus_torquatus, data=sp_train[,my_preds],
    maxnet.formula(p=sp_train$Turdus_torquatus, data=sp_train[,my_preds], classes=&quot;lh&quot;))

# HINT: try playing around with the classes=&quot;lqpht&quot; argument

# Now, we plot the response surface:
xyz$z &lt;- predict(m_maxent, xyz, type=&quot;logistic&quot;)
wireframe(z ~ bio11 + bio8, data = xyz, zlab = list(&quot;Occurrence prob.&quot;, rot=90), 
          drape = TRUE, col.regions = cls, scales = list(arrows = FALSE), 
          zlim = c(0, 1), main=&#39;Maxent&#39;, xlab=&#39;bio11&#39;, ylab=&#39;bio17&#39;, 
          screen=list(z = -120, x = -70, y = 3))</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<pre class="r"><code># Plot partial response curves:
par(mfrow=c(1,2)) 
partial_response(m_maxent, predictors = sp_train[,my_preds], main=&#39;Maxent&#39;)</code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-16-2.png" width="672" /></p>
<pre class="r"><code># Performance measures of GAM with spline-smoother 
(perf_maxent &lt;- evalSDM(sp_test$Turdus_torquatus, predict(m_maxent, sp_test[,my_preds],  type=&#39;logistic&#39;) ))</code></pre>
<pre><code>##         AUC       TSS     Kappa   Sens      Spec       PCC        D2 thresh
## 1 0.9384191 0.7610294 0.4656918 0.9375 0.8235294 0.8355263 0.3160077  0.265</code></pre>
<pre class="r"><code># Map predictions:
r_maxent_bin &lt;- r_maxent_pred &lt;- rasterFromXYZ(cbind(bio_curr_df[,1:2],
                                     predict(m_maxent, bio_curr_df, type=&quot;logistic&quot;)))
values(r_maxent_bin) &lt;- ifelse(values(r_maxent_pred)&gt;=perf_maxent$thresh, 1, 0)
plot(stack(r_maxent_pred, r_maxent_bin),main=c(&#39;Maxent prob.&#39;,&#39;Maxent bin.&#39;), axes=F)   </code></pre>
<p><img src="6_SDM_algorithms_files/figure-html/unnamed-chunk-16-3.png" width="672" /></p>
</div>
</div>
<div id="comparing-all-algorithms" class="section level2">
<h2><span class="header-section-number">2.4</span> Comparing all algorithms</h2>
<p>We can now compare the performance of all algorithms on our independent data. Also, we store this information for running the ensembles in the next tutorial.</p>
<pre class="r"><code>(comp_perf &lt;- rbind(bc = perf_bc, dom = perf_dom, glm = perf_glm, gamS = perf_gamS,
      cart = perf_cart, rf = perf_rf, brt = perf_brt, maxent = perf_maxent))</code></pre>
<pre><code>##              AUC       TSS     Kappa   Sens      Spec       PCC         D2
## bc     0.7948070 0.6102941 0.4317295 0.7500 0.8602941 0.8486842 -0.4583228
## dom    0.7821691 0.5441176 0.3274336 0.7500 0.7941176 0.7894737 -1.0856837
## glm    0.9333640 0.7352941 0.5006258 0.8750 0.8602941 0.8618421  0.4607125
## gamS   0.9375000 0.7757353 0.4912689 0.9375 0.8382353 0.8486842  0.4586095
## cart   0.8244485 0.6323529 0.4751381 0.7500 0.8823529 0.8684211  0.2546056
## rf     0.9067096 0.7205882 0.4728589 0.8750 0.8455882 0.8486842  0.2236552
## brt    0.9356618 0.7426471 0.3779233 1.0000 0.7426471 0.7697368  0.3950431
## maxent 0.9384191 0.7610294 0.4656918 0.9375 0.8235294 0.8355263  0.3160077
##        thresh
## bc      0.260
## dom     0.680
## glm     0.120
## gamS    0.100
## cart    0.320
## rf      0.120
## brt     0.020
## maxent  0.265</code></pre>
<pre class="r"><code># Adapt the file path to your folder structure
write.table(data.frame(alg=row.names(comp_perf),comp_perf), 
            file=&#39;data/SDM_alg_performances.txt&#39;, row.names=F)</code></pre>
<div class="alert alert-info">
<p><em><strong>Exercise:</strong></em></p>
<p>Use the species-climate data that you prepared for your own species (from practical 1 and 5) to run one or more of these algorithms.</p>
</div>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-araujo2007">
<p>Araujo, Miguel B., and Mark New. 2007. “Ensemble Forecasting of Species Distributions.” <em>Trends in Ecology and Evolution</em> 22: 42–47.</p>
</div>
<div id="ref-Booth2014">
<p>Booth, Trevor H., Henry A. Nix, John R. Busby, and Michael F. Hutchinson. 2014. “Bioclim: The First Species Distribution Modelling Package, Its Early Applications and Relevance to Most Current Maxent Studies.” <em>Diversity and Distributions</em> 20: 1–9.</p>
</div>
<div id="ref-BUISSON2010">
<p>Buisson, Laetitia, Wilfried Thuiller, Nicolas Casajus, Sovan Lek, and Gael Grenouillet. 2010. “Uncertainty in Ensemble Forecasting of Species Distribution.” <em>Global Change Biology</em> 16: 1145–57.</p>
</div>
<div id="ref-elith2006">
<p>Elith, J., C. H. Graham, R. P. Anderson, M. Dudik, S. Ferrier, A. Guisan, R. J. Hijmans, et al. 2006. “Novel Methods Improve Prediction of Species’ Distribution from Occurence Data.” <em>Ecography</em> 29: 129–51.</p>
</div>
<div id="ref-elith2008">
<p>Elith, J., J. R. Leathwick, and T. Hastie. 2008. “A Working Guide to Boosted Regression Trees.” <em>Journal of Animal Ecology</em> 77: 802–13.</p>
</div>
<div id="ref-Elith2011">
<p>Elith, J., S. J. Phillips, T. Hastie, M. Dudik, Y. E. Chee, and C. J. Yates. 2011. “A Statistical Explanation of Maxent for Ecologists.” <em>Diversity and Distributions</em> 17: 43–57.</p>
</div>
<div id="ref-Franklin2010">
<p>Franklin, J. 2010. <em>Mapping Species Distributions: Spatial Inference and Prediction</em>. Cambride University Press.</p>
</div>
<div id="ref-Gillings2019">
<p>Gillings, Simon, Dawn E. Balmer, Brian J. Caffrey, Iain S. Downie, David W. Gibbons, Peter C. Lack, James B. Reid, J. Tim R. Sharrock, Robert L. Swann, and Robert J. Fuller. 2019. “Breeding and Wintering Bird Distributions in Britain and Ireland from Citizen Science Bird Atlases.” <em>Global Ecology and Biogeography</em> 28 (7): 866–74. <a href="https://doi.org/10.1111/geb.12906">https://doi.org/10.1111/geb.12906</a>.</p>
</div>
<div id="ref-Guisan2017">
<p>Guisan, A., W. Thuiller, and N. E. Zimmermann. 2017. <em>Habitat Suitability and Distribution Models with Applications in R</em>. Cambride University Press.</p>
</div>
<div id="ref-Hastie2009">
<p>Hastie, T., R. Tibshirani, and J. Friedman. 2009. <em>The Elements of Statistical Learning</em>. Springer.</p>
</div>
<div id="ref-hutchinson1957">
<p>Hutchinson, G. E. 1957. “Concluding Remarks, Cold Spring Harbor Symposium.” <em>Quantitative Biology</em> 22: 415–27.</p>
</div>
<div id="ref-Kramer-Schadt2013">
<p>Kramer-Schadt, Stephanie, Juergen Niedballa, John D. Pilgrim, Boris Schroeder, Jana Lindenborn, Vanessa Reinfelder, Milena Stillfried, et al. 2013. “The Importance of Correcting for Sampling Bias in Maxent Species Distribution Models.” <em>Diversity and Distributions</em> 19 (11): 1366–79. <a href="https://doi.org/10.1111/ddi.12096">https://doi.org/10.1111/ddi.12096</a>.</p>
</div>
<div id="ref-Merow2013">
<p>Merow, C., M. J. Smith, and J. A. Silander Jr. 2013. “A Practical Guide to Maxent for Modeling Species’ Distributions: What It Does, and Why Inputs and Settings Matter.” <em>Ecography</em> 36: 1058–69.</p>
</div>
<div id="ref-phillips2006">
<p>Phillips, S. J., R. P. Anderson, and R. E. Schapire. 2006. “Maximum Entropy Modeling of Species Geographic Distributions.” <em>Ecological Modelling</em> 190: 231–59.</p>
</div>
<div id="ref-Thuiller2009">
<p>Thuiller, W., B. Lafourcade, R. Engler, and M. B. Araujo. 2009. “BIOMOD - a Platform for Ensemble Forecasting of Species Distributions.” <em>Ecography</em> 32: 369–73.</p>
</div>
<div id="ref-Zurell2020a">
<p>Zurell, Damaris, Janet Franklin, Christian König, Phil J. Bouchet, Carsten F. Dormann, Jane Elith, Guillermo Fandos, et al. 2020. “A Standard Protocol for Reporting Species Distribution Models.” <em>Ecography</em> 43 (9): 1261–77. <a href="https://doi.org/10.1111/ecog.04960">https://doi.org/10.1111/ecog.04960</a>.</p>
</div>
</div>
</div>

<!DOCTYPE html>
<html>

<br>
<hr />
<div id="footer">
<p>Damaris Zurell, 2020 <a href="http://creativecommons.org/licenses/by/4.0/" >(CC BY 4.0)</a>.  </p>
</div>

</html>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
